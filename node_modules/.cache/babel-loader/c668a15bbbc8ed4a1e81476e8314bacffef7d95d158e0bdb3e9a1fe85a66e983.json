{"ast":null,"code":"import React, { useEffect } from 'react';\nimport * as d3 from 'd3';\nimport L from 'leaflet';\nimport 'leaflet/dist/leaflet.css';\nconst map = L.map('map', {\n  zoomControl: false,\n  scrollWheelZoom: false,\n  doubleClickZoom: false,\n  dragging: false,\n  maxBounds: [[-90, -180], [90, 180]],\n  maxBoundsViscosity: 1.0\n}).setView([40, 0], 1.5);\n\n// Create a pane for the background layer\nmap.createPane('backgroundPane');\nmap.getPane('backgroundPane').style.zIndex = 100;\n\n// Add a solid-colored rectangle to cover the entire map\nL.rectangle([[-90, -180], [90, 180]], {\n  color: '#000000',\n  fillColor: '#000000',\n  fillOpacity: 1,\n  pane: 'backgroundPane'\n}).addTo(map);\n\n// Fetch and add geoJSON data to the map\nfetch('https://raw.githubusercontent.com/datasets/geo-countries/master/data/countries.geojson').then(response => response.json()).then(data => {\n  L.geoJSON(data, {\n    style: {\n      color: '#4A90E2',\n      weight: 0.5,\n      fillColor: '#000000',\n      fillOpacity: 0.5\n    },\n    onEachFeature: function (feature, layer) {\n      layer.on({\n        mouseover: function () {\n          layer.setStyle({\n            color: '#4A90E2',\n            weight: 1.5,\n            dashArray: '5, 5',\n            fillColor: '#4A90E2',\n            fillOpacity: 0.5\n          });\n        },\n        mouseout: function () {\n          layer.setStyle({\n            color: '#4A90E2',\n            weight: 0.5,\n            dashArray: '',\n            fillColor: '#000000',\n            fillOpacity: 0.5\n          });\n        }\n      });\n    }\n  }).addTo(map);\n});\n\n// Create an SVG layer on top of Leaflet\nconst svgLayer = d3.select(map.getPanes().overlayPane).append(\"svg\"),\n  g = svgLayer.append(\"g\").attr(\"class\", \"leaflet-zoom-hide\");\n\n// Define the attack data with source, destination, names, and threat type\nlet attackData = [{\n  id: 1,\n  source: [37.7749, -122.4194],\n  destination: [40.7128, -74.0060],\n  sourceName: 'USA',\n  destinationName: 'USA',\n  threatType: 'malware'\n}\n// ... add all your attack data here\n];\nlet currentIndex = 0;\n\n// Define the projection from geographical coordinates (lat, lon) to screen points\nfunction projectPoint(latlng) {\n  const point = map.latLngToLayerPoint(new L.LatLng(latlng[0], latlng[1]));\n  return [point.x, point.y];\n}\n\n// Function to redraw the attack lines and reposition the SVG\nfunction reset() {\n  const bounds = map.getBounds(),\n    topLeft = map.latLngToLayerPoint(bounds.getNorthWest()),\n    bottomRight = map.latLngToLayerPoint(bounds.getSouthEast());\n  svgLayer.attr('width', bottomRight.x - topLeft.x).attr('height', bottomRight.y - topLeft.y).style('left', `${topLeft.x}px`).style('top', `${topLeft.y}px`);\n  g.attr('transform', `translate(${-topLeft.x}, ${-topLeft.y})`);\n  showNextAttack();\n}\n\n// Function to display the next attack after the previous one reaches the destination\nfunction showNextAttack() {\n  if (currentIndex >= attackData.length) {\n    currentIndex = 0; // Reset if we reach the end of the attack data\n  }\n  const attack = attackData[currentIndex];\n  currentIndex++; // Move to the next attack in the list\n\n  const source = projectPoint(attack.source);\n  const destination = projectPoint(attack.destination);\n\n  // Mid-point for curvature\n  const midPoint = [(source[0] + destination[0]) / 2 + 100, (source[1] + destination[1]) / 2];\n\n  // Set color based on threat type\n  let lineColor;\n  switch (attack.threatType) {\n    case 'malware':\n      lineColor = 'red';\n      break;\n    case 'phishing':\n      lineColor = 'purple';\n      break;\n    case 'exploit':\n      lineColor = 'yellow';\n      break;\n    default:\n      lineColor = 'white';\n  }\n\n  // Create line generator for curved path\n  const lineGenerator = d3.line().curve(d3.curveBundle.beta(1)).x(d => d[0]).y(d => d[1]);\n\n  // Add attack line to SVG\n  const path = g.append(\"path\").datum([source, midPoint, destination]).attr(\"class\", \"attack-line\").attr(\"d\", lineGenerator).style(\"fill\", \"none\").style(\"stroke\", lineColor).style(\"stroke-width\", 2).style(\"opacity\", 0.8);\n\n  // Animate the attack line\n  path.transition().duration(2000).attrTween(\"stroke-dasharray\", function () {\n    const length = this.getTotalLength();\n    return d3.interpolateString(\"0,\" + length, length + \",\" + length);\n  }).on(\"end\", () => {\n    // Remove the path after animation\n    path.remove();\n    reset(); // Call reset to show the next attack\n  });\n}\n\n// Update the map on resize\nmap.on('resize', reset);\n\n// Initial reset to draw the first attack\nreset();","map":{"version":3,"names":["React","useEffect","d3","L","map","zoomControl","scrollWheelZoom","doubleClickZoom","dragging","maxBounds","maxBoundsViscosity","setView","createPane","getPane","style","zIndex","rectangle","color","fillColor","fillOpacity","pane","addTo","fetch","then","response","json","data","geoJSON","weight","onEachFeature","feature","layer","on","mouseover","setStyle","dashArray","mouseout","svgLayer","select","getPanes","overlayPane","append","g","attr","attackData","id","source","destination","sourceName","destinationName","threatType","currentIndex","projectPoint","latlng","point","latLngToLayerPoint","LatLng","x","y","reset","bounds","getBounds","topLeft","getNorthWest","bottomRight","getSouthEast","showNextAttack","length","attack","midPoint","lineColor","lineGenerator","line","curve","curveBundle","beta","d","path","datum","transition","duration","attrTween","getTotalLength","interpolateString","remove"],"sources":["/Users/harshitrishav/threat-map/src/components/MapComponent.js"],"sourcesContent":["import React, { useEffect } from 'react';\nimport * as d3 from 'd3';\nimport L from 'leaflet';\nimport 'leaflet/dist/leaflet.css';\n\n\nconst map = L.map('map', {\n    zoomControl: false,\n    scrollWheelZoom: false,\n    doubleClickZoom: false,\n    dragging: false,\n    maxBounds: [[-90, -180], [90, 180]],\n    maxBoundsViscosity: 1.0\n  }).setView([40, 0], 1.5);\n  \n  // Create a pane for the background layer\n  map.createPane('backgroundPane');\n  map.getPane('backgroundPane').style.zIndex = 100;\n  \n  // Add a solid-colored rectangle to cover the entire map\n  L.rectangle([[-90, -180], [90, 180]], {\n    color: '#000000',\n    fillColor: '#000000',\n    fillOpacity: 1,\n    pane: 'backgroundPane'\n  }).addTo(map);\n  \n  // Fetch and add geoJSON data to the map\n  fetch('https://raw.githubusercontent.com/datasets/geo-countries/master/data/countries.geojson')\n    .then(response => response.json())\n    .then(data => {\n      L.geoJSON(data, {\n        style: {\n          color: '#4A90E2',\n          weight: 0.5,\n          fillColor: '#000000',\n          fillOpacity: 0.5\n        },\n        onEachFeature: function (feature, layer) {\n          layer.on({\n            mouseover: function () {\n              layer.setStyle({\n                color: '#4A90E2',\n                weight: 1.5,\n                dashArray: '5, 5',\n                fillColor: '#4A90E2',\n                fillOpacity: 0.5\n              });\n            },\n            mouseout: function () {\n              layer.setStyle({\n                color: '#4A90E2',\n                weight: 0.5,\n                dashArray: '',\n                fillColor: '#000000',\n                fillOpacity: 0.5\n              });\n            }\n          });\n        }\n      }).addTo(map);\n    });\n  \n  // Create an SVG layer on top of Leaflet\n  const svgLayer = d3.select(map.getPanes().overlayPane).append(\"svg\"),\n    g = svgLayer.append(\"g\").attr(\"class\", \"leaflet-zoom-hide\");\n  \n  // Define the attack data with source, destination, names, and threat type\n  let attackData = [\n    { id: 1, source: [37.7749, -122.4194], destination: [40.7128, -74.0060], sourceName: 'USA', destinationName: 'USA', threatType: 'malware' },\n    // ... add all your attack data here\n  ];\n  \n  let currentIndex = 0; \n  \n  // Define the projection from geographical coordinates (lat, lon) to screen points\n  function projectPoint(latlng) {\n    const point = map.latLngToLayerPoint(new L.LatLng(latlng[0], latlng[1]));\n    return [point.x, point.y];\n  }\n  \n  // Function to redraw the attack lines and reposition the SVG\n  function reset() {\n    const bounds = map.getBounds(),\n      topLeft = map.latLngToLayerPoint(bounds.getNorthWest()),\n      bottomRight = map.latLngToLayerPoint(bounds.getSouthEast());\n  \n    svgLayer\n      .attr('width', bottomRight.x - topLeft.x)\n      .attr('height', bottomRight.y - topLeft.y)\n      .style('left', `${topLeft.x}px`)\n      .style('top', `${topLeft.y}px`);\n  \n    g.attr('transform', `translate(${-topLeft.x}, ${-topLeft.y})`);\n  \n    showNextAttack(); \n  }\n  \n  // Function to display the next attack after the previous one reaches the destination\n  function showNextAttack() {\n    if (currentIndex >= attackData.length) {\n      currentIndex = 0; // Reset if we reach the end of the attack data\n    }\n  \n    const attack = attackData[currentIndex];\n    currentIndex++; // Move to the next attack in the list\n  \n    const source = projectPoint(attack.source);\n    const destination = projectPoint(attack.destination);\n  \n    // Mid-point for curvature\n    const midPoint = [\n      (source[0] + destination[0]) / 2 + 100,\n      (source[1] + destination[1]) / 2\n    ];\n  \n    // Set color based on threat type\n    let lineColor;\n    switch (attack.threatType) {\n      case 'malware':\n        lineColor = 'red';\n        break;\n      case 'phishing':\n        lineColor = 'purple';\n        break;\n      case 'exploit':\n        lineColor = 'yellow';\n        break;\n      default:\n        lineColor = 'white';\n    }\n  \n    // Create line generator for curved path\n    const lineGenerator = d3.line()\n      .curve(d3.curveBundle.beta(1))\n      .x(d => d[0])\n      .y(d => d[1]);\n  \n    // Add attack line to SVG\n    const path = g.append(\"path\")\n      .datum([source, midPoint, destination])\n      .attr(\"class\", \"attack-line\")\n      .attr(\"d\", lineGenerator)\n      .style(\"fill\", \"none\")\n      .style(\"stroke\", lineColor)\n      .style(\"stroke-width\", 2)\n      .style(\"opacity\", 0.8);\n  \n    // Animate the attack line\n    path.transition()\n      .duration(2000)\n      .attrTween(\"stroke-dasharray\", function() {\n        const length = this.getTotalLength();\n        return d3.interpolateString(\"0,\" + length, length + \",\" + length);\n      })\n      .on(\"end\", () => {\n        // Remove the path after animation\n        path.remove();\n        reset(); // Call reset to show the next attack\n      });\n  }\n  \n  // Update the map on resize\n  map.on('resize', reset);\n  \n  // Initial reset to draw the first attack\n  reset();\n  "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}